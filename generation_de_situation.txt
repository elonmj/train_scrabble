# Algorithme de Génération de Grilles d'Entraînement Scrabble

## 1. Notations et Définitions

### 1.1 Données du problème
- GRILLE : grille de Scrabble 15x15
- D_MAX : distance maximale autorisée pour une connexion directe (ex: 6 cases)
- M = {m₁, m₂, ..., mₙ} : ensemble des mots à réviser
- T : tirage initial (ex: AAABCCR)
- A = {E, S, T} : lettres d'appui
- DICO : dictionnaire français complet
- Q : quota de mots cible pour le niveau de difficulté

### 1.2 Structures et Définitions Opérationnelles
- N : ensemble des mots non encore connectés
- S : sac de lettres disponibles 
- C = (V, E) : graphe de connexité où :
  * V = mots placés
  * E = {(m1, m2) | m1 et m2 s'intersectent sur la grille}
- PLACEMENT_VALIDE : un placement est valide si :
  * Le mot reste dans les limites de la grille 15x15
  * Pas de chevauchement illégal avec d'autres mots
  * Tous les mots formés sont dans DICO
- DISTANCE(m1, m2) : mesure la possibilité de connexion entre deux mots m1 et m2
  
  la distance suppose que les mots sont dans le même sens (horizontal ou vertical)
  si les deux mots sont dans des sens différents,
   la connexion doit se faire de manière croisée et est possible si le mot est dans la ligne adjacente ou la colonne adjacente à la colonne ou au mot voulue. 
  alors là la distance se calculera entre le mot et case la plus proche du mot à connecter en ajoutant + 3 en supposant que cette case peut n'avoir pas de croisement possible(formation d'un mot de 2 ou 3 lettres fondamentalement) 

  mais si ils sont dans le même sens, la distance est calculée entre les deux mots en prenant en compte la distance entre leurs lignes ou leurs colonnes
  à la condition que la colonne désirée( le point d'appui ou l'ensemble des colonnes des lettres du mots) coincide avec une colonne au moins des lettres du mot à connecter (NB dans un autre sens, il s'agit de lignes)
  si un le mot à un point d'appui, la distance est calculée entre ce point et l'autre mot
  sinon
  * Calculée entre les cases les plus proches des deux mots 
  avec retour des deux points d'appui appartenant aux deux mots(avec leur position)
  
  distance ne retourne pas qu'un chiffre, il retourne si une connexion est possible, si oui, les posiitions des deux lettres chacun appartenant à l'un des mots à connecter ou si c'est un croisement, la position du point d'appui et de la case minimale à atteindre

- CONNEXION_REUSSIE : une connexion est réussie si :
  * Le mot de connexion est dans DICO
  * Tous les mots croisés formés sont dans DICO
  * Les lettres utilisées respectent le sac S
  * Le placement est valide

### 1.3 Heuristiques et Scores
- SCORE_MOT(m) : calcule le score Scrabble d'un mot
- SCORE_CONNEXION(m1, m2) : évalue la qualité d'une connexion entre deux mots
  * Basé sur : nombre de lettres communes, score des mots formés
  * Bonus pour utilisation de lettres d'appui
- SCORE_PLACEMENT(m, pos) : évalue la qualité d'un placement
  * Distance au centre
  * Opportunités de connexions futures
  * Utilisation des cases bonus

### 1.4 Gestion des Erreurs et Stratégies de Repli
- ERREUR_PLACEMENT : types d'erreurs possibles lors du placement
  * HORS_GRILLE, CHEVAUCHEMENT, MOT_INVALIDE, LETTRES_INSUFFISANTES
- STRATEGIE_REPLI : actions à prendre en cas d'échec
  * ROTATION_MOT : essayer le même mot dans l'autre orientation
  * DEPLACEMENT : chercher une autre position valide
  * CHANGEMENT_MOT : passer au mot suivant temporairement
  * BACKTRACKING : revenir en arrière et modifier un placement précédent

## 2. Phase d'Initialisation

### 2.1 Placement du mot central
1. Choisir aléatoirement un mot w dans DICO avec les contraintes :
   - Longueur minimale : 4 lettres
   - Longueur maximale : 8 lettres
   - Contient au moins une lettre d'appui de A
2. Placer w horizontalement centré sur H8
3. V = {w}
4. Mettre à jour S en retirant les lettres de w

### 2.2 Placement des mots à réviser
Pour chaque mot m de M :
1. max_tentatives = 10
2. tentatives = 0
3. positions_testees = Set()
4. Tant que tentatives < max_tentatives :
   a. pos = GENERER_POSITION_INTELLIGENTE(m, w, V)
   b. Si pos in positions_testees :
      Continue
   c. positions_testees.add(pos)
   d. Pour orientation in [HORIZONTAL, VERTICAL] :
      Si PLACEMENT_VALIDE(m, pos.x, pos.y, orientation) :
         - Placer m
         - score = SCORE_PLACEMENT(m, pos)
         - Si score > SEUIL_SCORE_MINIMAL :
            * V = V ∪ {m}
            * N = N ∪ {m}
            * Break
   e. tentatives++
5. Si tentatives = max_tentatives :
   - Appliquer STRATEGIE_REPLI

## 3. Phase de Connexion

### 3.1 État initial
- N = M (tous les mots à réviser)
- S = {lettres du scrabble} - T
- Pour chaque mot placé non à réviser :
  * Retirer ses lettres de S sauf si point d'appui

### 3.2 Algorithme de connexion
max_iterations = |M| * 5  // Limite raisonnable d'itérations
iterations = 0

Tant que N ≠ ∅ et iterations < max_iterations :

1. Recherche du candidat :
   - distances = []
   Pour chaque mot m dans N :
     Pour chaque point d'appui a dans m :
       - d = DISTANCE(m, w)
       - distances.append((m, a, d))
   - Trier distances par d croissant
   - (m_min, a_min, d_min) = distances[0]

2. Analyse du placement et optimisation :
   - connexions_possibles = []
   Pour chaque dir dans directions_possibles :
     - mots_proches = TROUVER_MOTS_PROCHES(m_min, dir, D_MAX)
     Pour chaque p in mots_proches :
       - score = EVALUER_CONNEXION(m_min, p, dir)
       - connexions_possibles.append((p, score, dir))
   
   Si connexions_possibles non vide :
     - Trier connexions_possibles par score décroissant
     - Pour chaque (p, score, dir) in connexions_possibles :
       Si TENTER_CONNEXION(m_min, p, dir) :
         Break
   Sinon :
     - APPLIQUER_STRATEGIE_REPLI(m_min)

3. Types de connexion :
   a. Connexion avec mot intermédiaire :
      - candidats = GENERER_CANDIDATS_INTERMEDIAIRES(m_min, a_min, S)
      - Trier candidats par SCORE_CONNEXION décroissant
      - Pour chaque candidat c :
        * Si PLACEMENT_VALIDE(c) :
          - Placer c
          - V = V ∪ {c}
          - N = N - {m_min}
          - Break
      - Si aucun placement valide :
        * Retour à étape 1 avec point d'appui suivant

   b. Connexion vers mot proche :
      - Tenter connexion m_min vers p avec lettres de S
      - Si réussi :
        * N = N - {m_min}
        * Mettre à jour S
      - Sinon :
        * Retour à étape 1 avec point d'appui suivant

   c. Connexion vers mot central :
      - Tenter connexion m_min vers w avec lettres de S
      - Si réussi :
        * N = N - {m_min}
        * Mettre à jour S
      - Sinon :
        * Retour à étape 1 avec point d'appui suivant

## 4. Finalisation

### 4.1 Atteinte du quota
Si |V| < Q :
1. R = Q - |V|
2. mots_ajoutes = 0
3. max_tentatives_quota = R * 3
4. tentatives = 0

Tant que mots_ajoutes < R et tentatives < max_tentatives_quota :
   a. Choisir aléatoirement a dans A
   b. candidats = GENERER_MOTS_VALIDES(S, a, 3, 7)  // min=3, max=7 lettres
   c. Trier candidats par score décroissant
   Pour chaque mot dans candidats :
     Si PLACEMENT_VALIDE(mot) :
       - Placer mot
       - V = V ∪ {mot}
       - Mettre à jour S
       - mots_ajoutes++
       - Break
   d. tentatives++

### 4.2 Validation
1. Vérifier connexité :
   - Utiliser DFS depuis w pour vérifier que tous les mots de V sont accessibles
2. Vérifier mots M :
   - Tous les mots de M doivent être dans V
3. Vérifier validité :
   - Tous les mots horizontaux et verticaux doivent être dans DICO
4. Vérifier lettres :
   - Compteur de lettres utilisées ≤ distribution Scrabble initiale

Si une validation échoue :
   Retourner échec avec message approprié

### 4.3 Optimisation finale
1. Amélioration itérative :
   amelioration = true
   iterations = 0
   Tant que amelioration et iterations < MAX_ITERATIONS_OPTI :
     amelioration = false
     Pour chaque mot m dans V par ordre de priorité :
       Si PEUT_AMELIORER(m) :
         nouvelle_pos = TROUVER_MEILLEURE_POSITION(m)
         Si PLACEMENT_VALIDE(m, nouvelle_pos) :
           - Déplacer m
           - amelioration = true
     iterations++

2. Équilibrage spatial :
   - zones = ANALYSER_DENSITE_GRILLE()
   Pour chaque zone in zones_peu_denses :
     mots_courts = TROUVER_MOTS_COURTS_VALIDES(zone, S)
     Pour chaque mot in mots_courts :
       Si PLACEMENT_AMELIORE_EQUILIBRE(mot, zone) :
         Placer mot

3. Vérification finale :
   - Tous les mots de M sont bien placés
   - Distribution équilibrée des mots sur la grille
   - Scores des placements optimisés
   - Contraintes de lettres respectées

## 5. Sortie
- GRILLE complétée
- Graphe C connexe
- |V| ≥ Q mots placés
- Tous les mots de M connectés





## 2. Algorithme de Génération de Mots de Connexion Flexibles avec GADDAG Modifié

Cet algorithme s'intègre à l'étape 3.2 "Algorithme de connexion" de l'algorithme global de génération de grilles d'entraînement Scrabble.

**2.1 Entrées de l'Algorithme de Génération de Mots de Connexion**

Pour chaque tentative de connexion d'un mot cible `m_min` via un point d'appui `a_min`, l'algorithme reçoit les informations suivantes :

*   **Point d'appui (`a_min`) :** La lettre du mot `m_min` qui servira de point de connexion.
*   **Direction de connexion souhaitée :**  Horizontalement (gauche/droite) ou Verticalement (haut/bas).
*   **Sac de lettres disponibles (`S`) :** L'ensemble des lettres disponibles pour former le mot de connexion.
*   **État actuel de la GRILLE :**  Informations sur les lettres déjà placées sur la grille, notamment celles qui pourraient contraindre le placement du nouveau mot de connexion.

**2.2 Étapes de l'Algorithme de Génération de Mots de Connexion avec GADDAG Modifié**

L'algorithme suit les étapes ci-dessous pour générer un ensemble de mots de connexion potentiels :

**Étape 1 : Initialisation des Paramètres de Recherche**

*   **Définir une plage de longueurs de mots à tester :**  Par exemple, de `LONGUEUR_MIN` à `LONGUEUR_MAX` (peut être prédéfinie ou dynamique en fonction de l'espace disponible).
*   **Initialiser une liste vide `MOTS_DE_CONNEXION_POTENTIELS` :** Cette liste stockera les mots de connexion valides générés.

**Étape 2 : Itération sur les Longueurs de Mots Potentiels**

*   Pour chaque `longueur_mot` dans la plage définie (de `LONGUEUR_MIN` à `LONGUEUR_MAX`) :

    **Étape 2.1 : Itération sur les Positions du Point d'Appui**

    *   Pour chaque `position_appui` de 1 à `longueur_mot` :

        **Étape 2.1.1 : Création du "Mot Squelette"**

        *   Créer un "mot squelette" de longueur `longueur_mot` composé de caractères vides (`_`).
        *   Placer le point d'appui `a_min` à la `position_appui` dans le squelette.
        *   **Intégrer les lettres préexistantes de la GRILLE :**  Pour chaque position du "mot squelette", vérifier s'il existe une lettre déjà placée sur la GRILLE à la position correspondante pour cette connexion. Si oui, remplacer le caractère vide (`_`) par cette lettre préexistante dans le "mot squelette".

        **Étape 2.1.2 : Recherche avec GADDAG Modifié**

        *   Utiliser le GADDAG modifié pour rechercher tous les mots valides qui correspondent au "mot squelette", en respectant les contraintes suivantes :
            *   **Lettres disponibles du sac `S`**.
            *   **Lettres préexistantes** dans le "mot squelette" doivent être respectées (positions fixes).
            *   Le GADDAG doit explorer les préfixes et suffixes autour du point d'appui pour "remplir les blancs" du squelette.

        **Étape 2.1.3 : Validation et Filtrage des Mots Générés par le GADDAG**

        *   Pour chaque mot généré par le GADDAG :
            *   **Vérifier la validité du mot dans `DICO`**.
            *   **Vérifier l'utilisation correcte des lettres du sac `S`**.
            *   **Vérifier la validité de la connexion et du positionnement sur la GRILLE** (pas de chevauchement illégal, respect des lettres préexistantes, etc.).
            *   **Calculer une heuristique de directionnalité** (mesurant à quel point le mot s'étend dans la direction de connexion souhaitée).

        **Étape 2.1.4 : Ajout des Mots Valides à la Liste Potentielle**

        *   Si le mot passe toutes les validations et filtres, l'ajouter à la liste `MOTS_DE_CONNEXION_POTENTIELS`, en conservant également les informations associées : mot, position sur la grille, score potentiel, heuristique de directionnalité, etc.

**Étape 3 : Sélection du Meilleur Mot de Connexion (en dehors de cet algorithme spécifique)**

*   L'algorithme de génération de mots de connexion produit une liste de mots potentiels (`MOTS_DE_CONNEXION_POTENTIELS`).
*   **La sélection du "meilleur" mot de connexion parmi cette liste n'est *pas* réalisée par cet algorithme spécifique.**  Elle est effectuée par l'algorithme de connexion global (étape 3.2 de l'algorithme principal) en utilisant une **heuristique de connectivité de la grille**.  Cette heuristique prendra en compte des facteurs tels que :
    *   La connectivité globale de la grille après l'ajout du mot.
    *   Le score potentiel du mot de connexion.
    *   L'utilisation des lettres du sac.
    *   Potentiellement, l'heuristique de directionnalité calculée à l'étape 2.1.3.

**2.3 Sortie de l'Algorithme de Génération de Mots de Connexion**

L'algorithme retourne :

*   **`MOTS_DE_CONNEXION_POTENTIELS` :** Une liste de mots de connexion valides, potentiellement vide. Chaque élément de la liste contient :
    *   Le mot de connexion.
    *   La position de placement sur la GRILLE.
    *   Le score potentiel au Scrabble.
    *   L'heuristique de directionnalité.
    *   Autres informations pertinentes pour la sélection finale.

**2.4 Intégration dans l'Algorithme de Connexion Global**

Cet algorithme de génération de mots de connexion est un composant clé de l'étape 3.2 "Algorithme de connexion" de l'algorithme global de génération de grilles d'entraînement Scrabble.  Il est appelé pour chaque tentative de connexion d'un mot cible, fournissant une liste de candidats de connexion. L'algorithme de connexion global utilise ensuite ces candidats, ainsi que l'heuristique de connectivité de la grille, pour choisir et placer le meilleur mot de connexion, progressant ainsi vers la création d'une grille Scrabble complète et connectée.




Mots non connectés (3): {'BACCARAT', 'BACCARAS', 'CACABERA'}
===============================
Mots placés : BACCARAT, BACCARAS, CACABERA
Mots non placés :

=== Après placement des mots à réviser ===
 ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·
 ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·
 ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  B
 ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  A
 ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  C
 ·  ·  C  A  C  A  B  E  R  A  ·  ·  ·  ·  C
 ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  A
 ·  ·  ·  ·  ·  ·  S  A  T  E  ·  ·  ·  ·  R
 ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  A
 ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  S
 ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·
 ·  B  A  C  C  A  R  A  T  ·  ·  ·  ·  ·  ·
 ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·
 ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·
 ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·
=============================================


on a simplement deux cas soit, les mots sont dans la dans la même orientation soit il ne le sont pas.
dans le premier cas, on peut simplement calculer la distance et si il y a avait, une lettre d'appui, c'est sur sa colonne ou sa ligne( d'après l'orientation) qu'on calculerait la distance
mais si ssur cette ligne ou sur cette colonne, aucune lettre de l'autre mot n'apparaît, faut vérifier si il peut avoir une connexion adjacente( ils sont séparés d'une seule colonne ou d'une seule ligne et on pourrait trouver ainsi une mot transversal bref tu pénalises un peu cette distance)
dans le second cas, soit c'est un peu comme le mais du premier cas, la seule possibilité est un mot qui fait une maçonnerie sur quelques lettres de l'autre mot, donc tu dios retourner si par rapport à la lettre d'appui la colonne ou la ligne (selon les orientations) n'est que d'une case après ou avant et tu pénalises ça aussi
Et enfin si il n'y aucune contrainte de point d'appui, tu prends toutes les lettres des deux mots dans chaque cas et tu retournes la plus petite distance avec ces lettres